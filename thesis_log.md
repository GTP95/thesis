First idea to get users' data from PP was to use IRMA to disclose the data needed to compute the pseudonym to some component that would then proceed to generate it.
Doesn't work because the pseudonym is generated by encrypting a random string. But that random seed gets also stored inside salesforce, maybe I can get it from
there? To answer I need to know:
1. Is the seed stored along some data that uniquely identifies the user?
2. Does salesforce have some API to interface with other software?
The idea would be to develop a component that sits in front of salesforce. It authenticates the user using IRMA and then retrieves the correct identifier. Problem:
which component will then compute the pseudonym? To do that, you would need the private key that can't be given to the user. I would say that the component that
manages the authentication with the user could also compute the pseudonym and send it to the user (using an encrypted connection).
NOTE: Salesforce *does* have API access, but it also [depends on the edition]()(https://developer.salesforce.com/docs/atlas.en-us.242.0.api_rest.meta/api_rest/intro_rest_compatible_editions.htmi): "API access is available with Professional Edition, Performance Edition, Enterprise Edition, Unlimited Edition, and Developer Edition. For Professional
Edition, all requests for API access must be purchased and can be processed by contacting your Account Executive".
Accessing salesforce is a no-go. New idea: issue IRMA card with the identifier during the "enrollment" phase of a study participant.
PROBLEM: giving the participants their ID could reveal more than necessary. List of current ideas:
- Give participants their own ID during enrollment phase. 
    - Could be an unnecessary risk, plus they still need key material.
- Give participants a re-shuffled ID. 
    - Would solve the problem of giving them their real ID. They still need key material. How would this differ from creating a fake study?
- Create a fake study in which the participant has the researcher role. 
    - How would I insert the specific participant's data inside the fake study? Still need for key material
- Use IRMA's chained session: it is possible to derive a card from other cards the user already has by having the user disclose he attributes contained there. The server can then apply some function on the attributes and derive a new card from that. 
    - No need to use pseudonyms at all
    - Still need to provide the user with key material.


There is no column with the participant's pseudonym!!! It gets retrieved form somewhere else. Inside the row of a participant, I have the ParticipantIdentifier (the basis for getting a person's pseudonyms using reshuffling) and a ShortPseudinym, which is a random number that gets generated for each "sub-study" (i.e. for each medical test is done to the participant).
Currently, to give a participant access only to its own row, an administrator would need to create a group for each participant. 
Maybe another possibility is to write a new component separate from the rest of PEP that sits in front of it, with unlimited access to PEP that then gives to a user access to only its own data. But how can such a component link a user that authenticates via IRMA to its data? Actually there's an even bigger problem here:  such a component would have access to all *plaintext* data, since once enrolled in PEP would get a data key to be able to decrypt the data!. Even if I don't write code to actually decrypt the data, would this be an acceptable  single point of failure?
In the end, we decided to write a separate component, in the form of a web application, that integrates with PEP's login procedure. It works as another identity provider, the rest stays the same.

Problem: How to have some operations done server-side and other client-side inside the same webapp? It would be possible to use to different Rust web frameworks or
to write some JS code for the client-side. But then this would make it harder to use the `pepcli` tool to handle logging in and downloading files. Would running
everything client-side be an acceptable solution? The real problem here is if a malicious user would be able to trick the registration phase into generating a card with another user's credentials. But this doesn't seem a real issue though, as the registration phase is carried out in a "trusted" environment and not on the
user's PC. But still, how to use `pepcli`? Would it be possible to download it to the user's browser's local storage and use it from there? Or there is something
preventing me from using executables this way? 
I actually can't run everything client-side: a user could just send along the token making using IRMA pointless. So I need to mix client-side and server-side code.
A possible way of doing this is to convert `pepcli` to a `wasm` library and then call it from some `JS` code linked to the rest via static `HTML` files or templates.

Problem: after presenting the token to the auth server, I get an access token back. It would be desirable to have it sent directly to the user, without passing through the web app. But how? Use the rekey magic? It would solve the issue here! But I don't think the auth server support it...
Good thing: with `pepcli` it is possible to specify the access ticket with the -T flag, so propbably the step of obtaining a ticket and using it can be decoupled.
Temporary solution: since the webapp is just a PoC, have it forward the access token to the user (so use it in client-side code). Leave it as future work to modify the communication protocol between PEP servers so that the webapp can ask to have the token sent directly to the user's browser.
Good thing: it is possible to pass the (OAuth) token to `pepcli` as a string on the command line.
ACTUALLY, the problem was that I forgot the actual authenticaton flow. Here is how it would work in my case:

1. The user navigates to the website hosting the webapp and chooses to login with the Yivi app.
2. The web app displays the IRMA QR code and an IRMA session happens. The server-side gets the user's token and encapsulates it into a SAML file. 
3. That SAML file is sent to the user (actually the clien-side of the webapp).
And from now on, the procedure is the same as the usual one:
4. The webapp client-side presents the SAML file to the auth server
5. The  auth server replies with an OAuth token
6. The client-side presents the Oauth token to the key server
7. The key server replies with the ClientKeys file (again to the client-side)
8. The client-side presents some information therein contained to the access manager. The access manager talks with the transcriptor and gives back to the user a ticket
9. With the ticket, the client-side can get the data from the storage facility and use one of the keys of the Client keys file to decrypt it.

So in all this, I need to communicate directly with the auth server.

To build an Identity Provider, I first found this: [simplesamlphp-module-authirma](https://github.com/privacybydesign/simplesamlphp-module-authirma). It is a plugin for SimpleSAMLphp that adds IRMA as an identity provider. But it is unmantained, and developed at a time where the IRMA web server and the IRMA API server where two separate components. While trying to make it work again, I stumbled upon the problem of getting the keys for the API and web servers. Probably the key is the same for both, as now the irmago server implements both, but I wasn't able to find the certificate in the required format inside my Docker container.  
I then found this: [irma-idp](https://github.com/SURFnet/irma-idp). It is m ore recent, although it hasn't been updated in years too. But at least it targets the new irmago implementation that has bot web and API in the same piece of sw. But missing configuration instructions and again not able to find the required certificate (at least by trying the method reported in the README).

After talking with the PEP team, there are 3 possibilities:
1. Write a plugin for SimpleSAMLphp to have an IdP using IRMA
2. Write a middleware that sidesteps PEP's Apache server. On the same server running the auth server, there's an Apache server with the Sibboleth plugin. It 
communicates using SAML2.0 with the IdP (for now only SurfCONEXT) and, if the session between the two is successful, it sends some HTTP headers to the auth server
with the session's result. So it would be possible to write a middleware that stays on the side of the Apache server on the same machine and if the IRMA
authentication is successful sends to the auth server those HTTP headers. See `OAuthProvider::handleAuthorizationRequest` in 
`~/git/core-master/authserver/OAuthprovider.cpp` for how those headers shoukld look like and how are used.
3. Write a Rust middleware that implements SAML2.0 to communicate directly with Shibbolet.

### Possibilities evaluation
The first option let's keep a consistent picture: no special way to authenticate for participants. The drawback is that I don't know PHP, but since I was crazy
enough to use Rust just for this thesis it is an annoyance but not a real roadblock  

The second option has the advantage of letting me reuse the (little) Rust code I've already written. But then there would be two different ways to login depending on the user's role. In addition to this, it could be that the potential impact of a bug in my code would be more severe than in the case of a SimpleSAMLphp plugin  

The last option is the hardest, and so the one more likely to go wrong from a security perspective.
